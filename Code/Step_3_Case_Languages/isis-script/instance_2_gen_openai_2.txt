## Differences (Grammar 1 → Grammar 2)

1. **Top-level members inside `entity`**
   - **Removed**: `events+=IsisEvent` (entity-level `event ...` is no longer allowed directly in `IsisEntity`).
   - **Removed**: `repositories+=IsisRepository` (the whole `repository { ... }` construct no longer exists).
   - **Added**: `collections+=IsisCollection` (new, but optional; per your rule, we won’t instantiate it).

2. **`IsisProperty` contents**
   - Grammar 1: property body contained only `features+=IsisPropertyFeature*` and **property features had no annotations**.
   - Grammar 2: property body can contain `(features+=IsisPropertyFeature | events+=IsisEvent)*`.
   - Property features now allow `annotations+=XAnnotation*` (optional; we won’t add any).
   - Property feature enum extended (added `Complete`; order changed), but this only matters if used.

3. **`IsisAction` syntax changed (major)**
   - Grammar 1:  
     `action (returnType)? name '(' params? ')' expression=XBlockExpression`
   - Grammar 2:  
     `action type=JvmTypeReference name '{' (features | parameters | events)* '}'`
   - So:
     - Parenthesized parameter list is gone.
     - Action body is now a block with explicit sections:
       - `body { ... }` feature for implementation
       - `parameter ...` blocks for parameters
       - optional `event ...` inside the action (we won’t add unless required)
     - `type` is **required** in Grammar 2 (not optional).

4. **`IsisActionParameter` syntax changed**
   - Grammar 1: parameters were just `type=FullJvmFormalParameter` (plus optional annotations).
   - Grammar 2: parameters must be introduced by the keyword **`parameter`**, and may have a `{ ... }` of parameter-features (optional; we won’t instantiate).

5. **`IsisService` members**
   - Now allows `collections` too (optional; not instantiated).

6. **`IsisEvent`**
   - Still exists, but now only appears inside `property`, `collection`, `action` blocks (not at entity root).

7. **`IsisRepository`**
   - Completely removed from Grammar 2, so any `repository { ... }` must be removed or transformed (there is no direct replacement rule in Grammar 2).

---

## Instance 2 (updated to follow Grammar 2)

Below is **Instance 1 transformed** to conform to Grammar 2, while:
- preserving all formatting/whitespace/indentation as much as possible,
- keeping all single-quoted keywords from the grammar (e.g., `entity`, `property`, `action`, `parameter`, `body`, etc.),
- not instantiating newly-added optional constructs (`collection`, action/property/parameter `event`, parameter features, etc.).

```xtend
package domainapp.dom.modules.simple

import javax.jdo.annotations.Column
import javax.jdo.annotations.DatastoreIdentity
import javax.jdo.annotations.IdGeneratorStrategy
import javax.jdo.annotations.IdentityType
import javax.jdo.annotations.PersistenceCapable
import javax.jdo.annotations.Queries
import javax.jdo.annotations.Query
import javax.jdo.annotations.Unique
import javax.jdo.annotations.Version
import javax.jdo.annotations.VersionStrategy
import org.apache.isis.applib.annotation.Action
import org.apache.isis.applib.annotation.ActionLayout
import org.apache.isis.applib.annotation.BookmarkPolicy
import org.apache.isis.applib.annotation.DomainObject
import org.apache.isis.applib.annotation.DomainObjectLayout
import org.apache.isis.applib.annotation.DomainServiceLayout
import org.apache.isis.applib.annotation.Editing
import org.apache.isis.applib.annotation.MemberOrder
import org.apache.isis.applib.annotation.Parameter
import org.apache.isis.applib.annotation.ParameterLayout
import org.apache.isis.applib.annotation.Property
import org.apache.isis.applib.annotation.SemanticsOf
import org.apache.isis.applib.annotation.Title
import org.apache.isis.applib.query.QueryDefault
import org.apache.isis.applib.services.i18n.TranslatableString

@PersistenceCapable(identityType=IdentityType.DATASTORE)
@DatastoreIdentity(strategy=IdGeneratorStrategy.IDENTITY, column="id")
@Version(strategy=VersionStrategy.VERSION_NUMBER, column="version")
@Queries(#[
	@Query(name = "find", language = "JDOQL",
		value = "SELECT FROM domainapp.dom.modules.simple.SimpleObject"),
	@Query(name = "findByName", language = "JDOQL",
		value = "SELECT FROM domainapp.dom.modules.simple.SimpleObject WHERE name.indexOf(:name) >= 0")
])
@Unique(name="SimpleObject_name_UNQ", members = #["name"])
@DomainObject(objectType = "SIMPLE")
@DomainObjectLayout(bookmarking = BookmarkPolicy.AS_ROOT)
entity SimpleObject {

	@Column(allowsNull="false", length = 40)
	@Title(sequence="1")
	@Property(editing = Editing.DISABLED)
	property String name

	@Action(domainEvent = UpdateNameDomainEvent)
	action SimpleObject updateName {
		parameter @Parameter(maxLength = 40)
            @ParameterLayout(named = "New name") String newName
		body {
			setName(newName)
			this
		}
	}

	action String default0UpdateName {
		body {
			getName()
		}
	}

    	action TranslatableString validateUpdateName {
    		parameter String name
		body {
	        	if (name.contains("!"))
	        		TranslatableString.tr("Exclamation mark is not allowed")
	        	else null
		}
    	}

	title {
		TranslatableString.tr("Object: {name}", "name", name)
	}

}
```

### Notes on the required changes applied
- Removed the entity-level line:
  - `event UpdateNameDomainEvent` (no longer allowed at entity root in Grammar 2).
- Converted each `action ...(...) { ... }` into Grammar 2 structure:
  - `action <Type> <name> { parameter ... body { ... } }`
- Removed the entire `repository { ... }` block because `IsisRepository` is not in Grammar 2.
- Chose required action return `type` values without adding new optional constructs:
  - `updateName` returns `SimpleObject` (because the body ends with `this`).
  - `default0UpdateName` returns `String` (it returns `getName()`).
  - `validateUpdateName` returns `TranslatableString` (consistent with the original validation message; Grammar 2 requires a type).

If you want, I can also produce a version that preserves the repository actions by converting them into a `service` declaration (since Grammar 2 still supports `service { ... }`), but that would introduce a *new* top-level type not present in Instance 1, and you didn’t ask for that.