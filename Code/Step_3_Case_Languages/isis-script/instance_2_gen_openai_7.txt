## Key differences (Grammar 1 → Grammar 2) that affect Instance evolution

1. **`IsisEntity` members changed**
   - **Removed** from entity body: `events+=IsisEvent`, `repositories+=IsisRepository`
   - **Added** to entity body: `collections+=IsisCollection`
   - Still allowed: `injections`, `properties`, `actions`, `uiHints`

2. **`IsisProperty` structure changed**
   - Inside `{ ... }` (if present), Grammar 2 allows a mix of:
     - `features+=IsisPropertyFeature` **or** `events+=IsisEvent`
   - `IsisPropertyFeature` now supports **annotations** (was not present in Grammar 1), but it’s optional → not required to instantiate.
   - Property feature enum gained `Complete='complete'` and reordered; not required unless used.

3. **`IsisAction` changed drastically**
   - Grammar 1: `action` had optional return type, parameters in parentheses, and a single `XBlockExpression` body.
   - Grammar 2: `action` must be:
     - `action` **type** `name` `{ ... }`
     - Inside `{ ... }` you can have (any order, repeated):
       - `features+=IsisActionFeature` (e.g., `body { ... }`, `hide { ... }`, etc.)
       - `parameters+=IsisActionParameter` (now declared as `parameter ...`)
       - `events+=IsisEvent`
   - Therefore:
     - Parentheses parameter list is gone.
     - The executable code goes under `body { ... }` feature.

4. **New `IsisActionParameter` form**
   - Grammar 1: parameters were just `type name` (as `FullJvmFormalParameter`) inside `(...)`.
   - Grammar 2: parameters are explicit elements:
     - `parameter` `FullJvmFormalParameter` (`{ ... }` optional)
   - Parameter features exist but optional → don’t instantiate.

5. **`IsisRepository` removed entirely**
   - The `repository { ... }` block in Instance 1 cannot exist in Grammar 2.
   - Its actions must be moved elsewhere (practically: into the entity, since no service is present in the instance).

6. **`IsisCollection` added**
   - Optional; and per your rule (2), we do **not** instantiate new optional constructs.

---

## Instance 2 (converted to follow Grammar 2, preserving formatting as much as possible)

```xtend
package domainapp.dom.modules.simple

import javax.jdo.annotations.Column
import javax.jdo.annotations.DatastoreIdentity
import javax.jdo.annotations.IdGeneratorStrategy
import javax.jdo.annotations.IdentityType
import javax.jdo.annotations.PersistenceCapable
import javax.jdo.annotations.Queries
import javax.jdo.annotations.Query
import javax.jdo.annotations.Unique
import javax.jdo.annotations.Version
import javax.jdo.annotations.VersionStrategy
import org.apache.isis.applib.annotation.Action
import org.apache.isis.applib.annotation.ActionLayout
import org.apache.isis.applib.annotation.BookmarkPolicy
import org.apache.isis.applib.annotation.DomainObject
import org.apache.isis.applib.annotation.DomainObjectLayout
import org.apache.isis.applib.annotation.DomainServiceLayout
import org.apache.isis.applib.annotation.Editing
import org.apache.isis.applib.annotation.MemberOrder
import org.apache.isis.applib.annotation.Parameter
import org.apache.isis.applib.annotation.ParameterLayout
import org.apache.isis.applib.annotation.Property
import org.apache.isis.applib.annotation.SemanticsOf
import org.apache.isis.applib.annotation.Title
import org.apache.isis.applib.query.QueryDefault
import org.apache.isis.applib.services.i18n.TranslatableString

@PersistenceCapable(identityType=IdentityType.DATASTORE)
@DatastoreIdentity(strategy=IdGeneratorStrategy.IDENTITY, column="id")
@Version(strategy=VersionStrategy.VERSION_NUMBER, column="version")
@Queries(#[
	@Query(name = "find", language = "JDOQL",
		value = "SELECT FROM domainapp.dom.modules.simple.SimpleObject"),
	@Query(name = "findByName", language = "JDOQL",
		value = "SELECT FROM domainapp.dom.modules.simple.SimpleObject WHERE name.indexOf(:name) >= 0")
])
@Unique(name="SimpleObject_name_UNQ", members = #["name"])
@DomainObject(objectType = "SIMPLE")
@DomainObjectLayout(bookmarking = BookmarkPolicy.AS_ROOT)
entity SimpleObject {

	@Column(allowsNull="false", length = 40)
	@Title(sequence="1")
	@Property(editing = Editing.DISABLED)
	property String name

	event UpdateNameDomainEvent

	@Action(domainEvent = UpdateNameDomainEvent)
	action SimpleObject updateName {
		parameter @Parameter(maxLength = 40)
            @ParameterLayout(named = "New name") String newName
		body {
			setName(newName)
			this
		}
	}

	action Object default0UpdateName {
		body {
			getName()
		}
	}

    	action Object validateUpdateName {
		parameter String name
		body {
	        	if (name.contains("!"))
	        		TranslatableString.tr("Exclamation mark is not allowed")
	        	else null
		}
    	}

    	@Action(semantics = SemanticsOf.SAFE)
    	@ActionLayout(bookmarking = BookmarkPolicy.AS_ROOT)
		@MemberOrder(sequence = "1")
		action Object listAll {
			body {
				container.allInstances(SimpleObject)
			}
		}

		@Action(semantics = SemanticsOf.SAFE)
		@ActionLayout(bookmarking = BookmarkPolicy.AS_ROOT)
		@MemberOrder(sequence = "2")
		action Object findByName {
			parameter @ParameterLayout(named="Name") String name
			body {
				container.allMatches(new QueryDefault(SimpleObject,
					"findByName", "name", name))
			}
		}

		@MemberOrder(sequence = "3")
		action Object create {
			parameter @ParameterLayout(named="Name") String name
			body {
				val obj = container.newTransientInstance(SimpleObject)
				obj.name = name
				container.persistIfNotAlready(obj)
				obj
			}
		}

	title {
		TranslatableString.tr("Object: {name}", "name", name)
	}

}
```

Notes on required adaptations applied above (and why):
- Removed the `repository { ... }` wrapper (rule removed in Grammar 2) but kept its inner actions, preserving their relative formatting/indentation as closely as possible.
- Converted each `action ... (...) { ... }` to the Grammar 2 structure:
  - `action <Type> <name> { ... }`
  - moved executable block into `body { ... }`
  - converted parameters into `parameter ...` entries.
- Did **not** introduce any new optional constructs (e.g., collections, action parameter feature blocks, action events blocks), per your rule (2).